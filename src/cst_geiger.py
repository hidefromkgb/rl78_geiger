import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider



alphas = [
    1,      # 00
    1,      # 01
    1 / 2,  # 02
    1 / 3,  # 03
    1 / 4,  # 04
    1 / 5,  # 05
    1 / 6,  # 06
    1 / 7,  # 07
    1 / 8,  # 08
    1 / 9,  # 09
    1 / 10, # 10
    1 / 11, # 11
    1 / 12, # 12
    1 / 13, # 13
    1 / 14, # 14
    1 / 15, # 15
    1 / 16, # 16
    1 / 16, # 17
    1 / 16, # 18
    1 / 16, # 19
    1 / 16, # 20
    1 / 16, # 21
    1 / 16, # 22
    1 / 16, # 23
    1 / 16, # 24
    1 / 16, # 25
    1 / 16, # 26
    1 / 16, # 27
    1 / 16, # 28
    1 / 16, # 29
    1 / 16, # 30
    1 / 16, # 31
    1 / 16, # 32
    1 / 16, # 33
    1 / 16, # 34
    1 / 16, # 35
    1 / 16, # 36
    1 / 16, # 37
    1 / 16, # 38
    1 / 16, # 39
    1 / 16, # 40
    1 / 16, # 41
    1 / 16, # 42
    1 / 16, # 43
    1 / 16, # 44
    1 / 16, # 45
    1 / 16, # 46
    1 / 16, # 47
    1 / 16, # 48
    1 / 16, # 49
    1 / 16, # 50
    1 / 16, # 51
    1 / 16, # 52
    1 / 16, # 53
    1 / 16, # 54
    1 / 16, # 55
    1 / 16, # 56
    1 / 16, # 57
    1 / 16, # 58
    1 / 16, # 59
    1 / 16, # 60
    1 / 16, # 61
    1 / 16, # 62
    1 / 16, # 63
    1 / 16,
]

# Define the reference functions
ref_array = np.concatenate((
    np.full(120, 10),
    np.full(120, 5),
    np.full(120, 100),
    np.fromfunction(lambda i: 60 - 0.5 * i, (120,)),
    np.fromfunction(lambda i: 300/(np.sqrt(2 * np.pi)) * np.exp(-((i - 60)/15)**2 / 2), (120,)),
    np.fromfunction(lambda i: 300/(np.sqrt(2 * np.pi)) * np.exp(-((i - 60)/15)**2 / 2), (120,)),
    np.full(120, 0.33),
    np.full(120, 0.66),
    np.full(120, 0.99),
    np.fromfunction(lambda i: 20/(np.sqrt(2 * np.pi)) * np.exp(-((i - 60)/15)**2 / 2) + 0.99, (120,)),
    np.full(120, 0.5),
    np.full(120, 0.3),
    np.full(360, 0.1),
))

'''
ref_array = [
0x80, 0x81, 0x80, 0x80, 0x81, 0x81, 0x82, 0x82, 0x83, 0x84, 0x85, 0x85, 0x86, 0x87, 0x88, 0x89,
0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x92, 0x93, 0x93, 0x94, 0x94, 0x95,
0x95, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x95, 0x95, 0x95, 0x94, 0x94, 0x93, 0x92,
0x92, 0x91, 0x90, 0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x88, 0x87, 0x86, 0x85, 0x83, 0x82, 0x81,
0x80, 0x7e, 0x7d, 0x7b, 0x79, 0x77, 0x75, 0x73, 0x71, 0x6e, 0x6c, 0x6a, 0x68, 0x65, 0x63, 0x61,
0x5f, 0x5d, 0x5b, 0x59, 0x57, 0x55, 0x54, 0x52, 0x51, 0x4f, 0x4e, 0x4d, 0x4c, 0x4c, 0x4b, 0x4b,
0x4b, 0x4a, 0x4b, 0x4b, 0x4b, 0x4c, 0x4c, 0x4d, 0x4e, 0x4f, 0x51, 0x52, 0x53, 0x55, 0x57, 0x59,
0x5b, 0x5d, 0x5f, 0x61, 0x63, 0x66, 0x68, 0x6b, 0x6d, 0x70, 0x72, 0x75, 0x77, 0x79, 0x7b, 0x7d,
0x80, 0x81, 0x83, 0x85, 0x87, 0x89, 0x8a, 0x8c, 0x8e, 0x8f, 0x90, 0x92, 0x93, 0x94, 0x95, 0x96,
0x96, 0x97, 0x98, 0x99, 0x99, 0x99, 0x9a, 0x9a, 0x9a, 0x98, 0x9a, 0x9a, 0x99, 0x99, 0x99, 0x98,
0x97, 0x97, 0x96, 0x95, 0x94, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89,
0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x80, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x80, 0x80, 0x80, 0x80, 0x7f, 0x7f, 0x7e, 0x7e, 0x7d,
0x7d, 0x7c, 0x7c, 0x7b, 0x7a, 0x7a, 0x79, 0x79, 0x78, 0x77, 0x77, 0x76, 0x76, 0x75, 0x75, 0x74,
0x74, 0x73, 0x73, 0x72, 0x72, 0x72, 0x72, 0x72, 0x71, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x72,
0x72, 0x73, 0x73, 0x74, 0x74, 0x75, 0x76, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
0x80, 0x81, 0x82, 0x84, 0x85, 0x87, 0x88, 0x8a, 0x8b, 0x8d, 0x8f, 0x90, 0x92, 0x93, 0x95, 0x96,
0x98, 0x99, 0x9a, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa0, 0xa1, 0xa2, 0xa2, 0xa3, 0xa3, 0xa3, 0xa3,
0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0xa2, 0xa1, 0xa0, 0xa0, 0x9f, 0x9e, 0x9d, 0x9c, 0x9a, 0x99, 0x98,
0x96, 0x95, 0x93, 0x92, 0x90, 0x8f, 0x8d, 0x8c, 0x8a, 0x89, 0x87, 0x86, 0x84, 0x83, 0x82, 0x81,
0x80, 0x7f, 0x7e, 0x7d, 0x7d, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7f, 0x7d, 0x7d, 0x7e, 0x7e, 0x7f,
0x80, 0x80, 0x81, 0x82, 0x83, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x89, 0x8a, 0x8b, 0x8c,
0x8d, 0x8d, 0x8e, 0x8e, 0x8f, 0x8f, 0x90, 0x90, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
0x90, 0x90, 0x90, 0x8f, 0x8e, 0x8e, 0x8d, 0x8c, 0x8b, 0x8b, 0x89, 0x87, 0x86, 0x85, 0x83, 0x81,
0x80, 0x7e, 0x7c, 0x7a, 0x79, 0x77, 0x77, 0x74, 0x73, 0x72, 0x71, 0x6f, 0x6e, 0x6c, 0x6d, 0x6c,
0x6b, 0x6b, 0x6a, 0x6a, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6b, 0x6a, 0x6a, 0x6b,
0x6c, 0x6d, 0x6d, 0x6e, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
0x7a, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7e, 0x7f, 0x7f, 0x80, 0x80, 0x80, 0x81, 0x80, 0x80, 0x80,
0x80, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x80, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x85,
0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x94, 0x95,
0x96, 0x96, 0x97, 0x97, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x97, 0x97, 0x96,
0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8e, 0x8d, 0x8c, 0x8a, 0x89, 0x87, 0x85, 0x83, 0x81,
0x80, 0x7e, 0x7c, 0x7a, 0x79, 0x77, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x71, 0x70, 0x70, 0x70,
0x70, 0x6f, 0x6f, 0x70, 0x70, 0x70, 0x72, 0x71, 0x71, 0x72, 0x72, 0x73, 0x73, 0x74, 0x75, 0x76,
0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x82, 0x83,
0x84, 0x84, 0x85, 0x85, 0x85, 0x85, 0x86, 0x86, 0x85, 0x85, 0x85, 0x85, 0x84, 0x83, 0x82, 0x81,
0x80, 0x7e, 0x7d, 0x7b, 0x79, 0x77, 0x76, 0x74, 0x72, 0x70, 0x6e, 0x6d, 0x6b, 0x69, 0x67, 0x66,
0x64, 0x62, 0x61, 0x60, 0x5e, 0x5d, 0x5c, 0x59, 0x5a, 0x59, 0x58, 0x58, 0x57, 0x57, 0x57, 0x57,
0x57, 0x57, 0x57, 0x55, 0x58, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5c, 0x5f, 0x61, 0x62, 0x64,
0x65, 0x67, 0x69, 0x6a, 0x6c, 0x6e, 0x70, 0x71, 0x73, 0x75, 0x77, 0x78, 0x7a, 0x7b, 0x7d, 0x7e,
0x80, 0x81, 0x82, 0x84, 0x85, 0x87, 0x89, 0x8b, 0x8d, 0x8f, 0x91, 0x94, 0x96, 0x98, 0x9a, 0x9c,
0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa7, 0xa9, 0xaa, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb1, 0xb2,
0xb2, 0xb2, 0xb2, 0xb2, 0xb1, 0xb1, 0xb0, 0xb0, 0xaf, 0xae, 0xad, 0xab, 0xaa, 0xa8, 0xa7, 0xa5,
0xa3, 0xa1, 0x9f, 0x9d, 0x9b, 0x98, 0x96, 0x94, 0x91, 0x8f, 0x8d, 0x8a, 0x88, 0x86, 0x84, 0x82,
0x80, 0x7d, 0x7b, 0x79, 0x77, 0x74, 0x72, 0x70, 0x6d, 0x6b, 0x68, 0x66, 0x64, 0x61, 0x5f, 0x5d,
0x5b, 0x59, 0x57, 0x55, 0x54, 0x52, 0x51, 0x50, 0x4e, 0x4d, 0x4d, 0x4c, 0x4b, 0x4b, 0x4b, 0x4b,
0x4b, 0x4b, 0x4c, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x54, 0x55, 0x57, 0x59, 0x5b, 0x5d,
0x5f, 0x61, 0x63, 0x66, 0x68, 0x6a, 0x6c, 0x6f, 0x71, 0x73, 0x75, 0x77, 0x79, 0x7b, 0x7d, 0x7e,
0x80, 0x81, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c,
0x9e, 0xa0, 0xa2, 0xa4, 0xa5, 0xa7, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xaf, 0xb0, 0xb0,
0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xaf, 0xaf, 0xae, 0xad, 0xac, 0xab, 0xa9, 0xa8, 0xa4, 0xa5, 0xa3,
0xa1, 0x9f, 0x9d, 0x9b, 0x99, 0x97, 0x95, 0x92, 0x90, 0x8e, 0x8c, 0x89, 0x87, 0x85, 0x83, 0x81,
0x80, 0x7e, 0x7c, 0x7a, 0x78, 0x76, 0x73, 0x71, 0x6f, 0x6d, 0x6a, 0x68, 0x66, 0x64, 0x62, 0x60,
0x5e, 0x5c, 0x5a, 0x59, 0x57, 0x56, 0x54, 0x53, 0x52, 0x51, 0x50, 0x50, 0x4f, 0x4f, 0x4e, 0x4e,
0x4e, 0x4f, 0x4f, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x58, 0x59, 0x5b, 0x5d, 0x5f,
0x61, 0x63, 0x65, 0x67, 0x69, 0x6b, 0x6d, 0x6f, 0x71, 0x73, 0x75, 0x77, 0x7b, 0x7b, 0x7d, 0x7e,
0x80, 0x81, 0x82, 0x84, 0x86, 0x87, 0x8b, 0x8b, 0x8d, 0x8f, 0x91, 0x93, 0x94, 0x96, 0x98, 0x9a,
0x9c, 0x9d, 0x9f, 0xa0, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xab, 0xaa, 0xaa, 0xaa,
0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0xa9, 0xa8, 0xa7, 0xa7, 0xa6, 0xa4, 0xa3, 0xa2, 0xa1, 0x9f, 0x9d,
0x9c, 0x9a, 0x98, 0x97, 0x95, 0x93, 0x91, 0x8f, 0x8d, 0x8b, 0x89, 0x88, 0x86, 0x84, 0x82, 0x81,
0x80, 0x7e, 0x7d, 0x7b, 0x7a, 0x78, 0x76, 0x75, 0x74, 0x72, 0x71, 0x70, 0x6e, 0x6d, 0x6c, 0x6b,
0x69, 0x68, 0x67, 0x66, 0x65, 0x65, 0x64, 0x63, 0x63, 0x62, 0x62, 0x62, 0x62, 0x61, 0x61, 0x62,
0x62, 0x62, 0x62, 0x63, 0x63, 0x64, 0x65, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x77, 0x78, 0x7a, 0x7b, 0x7c, 0x7d, 0x7d, 0x7e, 0x7f,
0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80, 0x80, 0x80, 0x7f,
0x7f, 0x7f, 0x7e, 0x7e, 0x7d, 0x7d, 0x7d, 0x7c, 0x7c, 0x7b, 0x7b, 0x7a, 0x7a, 0x79, 0x79, 0x79,
0x78, 0x78, 0x78, 0x77, 0x77, 0x77, 0x77, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76,
0x76, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78, 0x79, 0x7b, 0x7a, 0x7b, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x80, 0x81, 0x82, 0x82, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x82, 0x82, 0x82,
0x81, 0x81, 0x80, 0x80, 0x7f, 0x7e, 0x7e, 0x7d, 0x7c, 0x7c, 0x7b, 0x7a, 0x7a, 0x79, 0x78, 0x78,
0x77, 0x76, 0x76, 0x75, 0x75, 0x74, 0x74, 0x74, 0x73, 0x73, 0x73, 0x73, 0x72, 0x72, 0x72, 0x72,
0x73, 0x73, 0x73, 0x73, 0x74, 0x74, 0x75, 0x76, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7d, 0x7e,
0x80, 0x81, 0x83, 0x85, 0x87, 0x89, 0x8b, 0x8d, 0x90, 0x92, 0x94, 0x97, 0x99, 0x9c, 0x9e, 0xa0,
0xa2, 0xa5, 0xa7, 0xa9, 0xab, 0xac, 0xae, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb6, 0xb7,
0xb7, 0xb7, 0xb7, 0xb7, 0xb6, 0xb6, 0xb5, 0xb4, 0xb3, 0xb2, 0xb0, 0xaf, 0xad, 0xab, 0xaa, 0xa8,
0xa5, 0xa3, 0xa1, 0x9f, 0x9c, 0x9a, 0x97, 0x95, 0x92, 0x90, 0x8d, 0x8b, 0x88, 0x86, 0x84, 0x82,
0x80, 0x7e, 0x7c, 0x7a, 0x78, 0x76, 0x74, 0x72, 0x70, 0x6f, 0x6d, 0x6c, 0x6a, 0x69, 0x68, 0x66,
0x65, 0x64, 0x63, 0x62, 0x62, 0x61, 0x61, 0x60, 0x60, 0x60, 0x5f, 0x5f, 0x60, 0x60, 0x60, 0x60,
0x61, 0x61, 0x62, 0x63, 0x64, 0x64, 0x65, 0x66, 0x68, 0x69, 0x68, 0x6b, 0x6c, 0x6e, 0x6f, 0x70,
0x72, 0x73, 0x76, 0x75, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7e, 0x7f, 0x7f, 0x7f,
0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8c,
0x8d, 0x8e, 0x90, 0x91, 0x92, 0x93, 0x94, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9b, 0x9c, 0x9d,
0x9d, 0x9e, 0x9e, 0x9e, 0x9e, 0x9f, 0x9f, 0x9e, 0x9e, 0x9e, 0x9d, 0x9d, 0x9c, 0x9c, 0x9b, 0x9a,
0x99, 0x98, 0x97, 0x95, 0x94, 0x93, 0x91, 0x90, 0x8e, 0x8c, 0x8b, 0x89, 0x87, 0x85, 0x83, 0x81,
0x80, 0x7e, 0x7c, 0x7a, 0x79, 0x77, 0x76, 0x74, 0x73, 0x70, 0x71, 0x70, 0x70, 0x6f, 0x6e, 0x6e,
0x6e, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6e, 0x6e, 0x6f, 0x6f, 0x70, 0x70, 0x71,
0x72, 0x73, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x80, 0x81, 0x81, 0x82, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x82, 0x82, 0x81, 0x80,
0x80, 0x7e, 0x7d, 0x7c, 0x7a, 0x78, 0x77, 0x75, 0x73, 0x71, 0x6f, 0x6d, 0x6b, 0x69, 0x67, 0x64,
0x64, 0x62, 0x60, 0x5e, 0x5d, 0x5b, 0x5a, 0x59, 0x57, 0x56, 0x55, 0x54, 0x54, 0x53, 0x53, 0x52,
0x52, 0x52, 0x52, 0x52, 0x52, 0x53, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c, 0x5e,
0x60, 0x61, 0x63, 0x65, 0x67, 0x69, 0x6b, 0x6d, 0x6f, 0x71, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
0x81, 0x81, 0x83, 0x85, 0x86, 0x88, 0x8a, 0x8b, 0x8d, 0x8e, 0x90, 0x91, 0x93, 0x94, 0x95, 0x96,
0x97, 0x98, 0x99, 0x9a, 0x9a, 0x9b, 0x9b, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
0x9b, 0x9b, 0x9a, 0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90, 0x8f, 0x8d,
0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x86, 0x85, 0x84, 0x83, 0x83, 0x82, 0x81, 0x81, 0x80, 0x80, 0x80,
]
ref_array = (np.float64(ref_array) - 75) / 40
'''

#ref_array += 8000
src_array = np.zeros(len(ref_array), dtype=int)



# Centered significance test
# DOI: 10.1109/tns.2016.2601785
def cst(array):
    max_window_size = 64

    output = []
    event_buf = np.zeros(max_window_size, dtype=int)
    buf_head = 0
    lambda_cur = 0
    lambda_prev = 0
    sigma_cur = 0
    sigma_prev = 0

    l_t = int(max_window_size / 2)
    t_a = 1.0

    for idx, sample in enumerate(array):
        L = 0
        event_buf[buf_head] = sample
        buf_idx = buf_head
        event_sum = sample

        for i in range(1, l_t):
            buf_idx -= 1
            if buf_idx < 0:
                buf_idx = max_window_size - 1

            event_sum += event_buf[buf_idx]
            lambda_cur = event_sum / (i+1)
            sigma_cur = lambda_cur / (i+1)

            if ((lambda_cur - lambda_prev)**2) > (t_a**2 * (sigma_cur + sigma_prev)):
                L += 1

        l_t = l_t - L + 1
        lambda_prev = lambda_cur
        sigma_prev = sigma_cur
        buf_head += 1
        if buf_head >= max_window_size:
            buf_head = 0

        output.append(lambda_cur)

    return output

def cst_mcu(array, t_a = 0x0100):
    # for n in $(seq 0 4095); do printf "0x%04X " $n; echo "sqrt($n/256)" | bc -l; done
    size_max = 64 # keep this value at 64 or lower

    event_buf = np.zeros(size_max, dtype=int)
    event_idx = 0 # starting value doesn't matter, safe to skip initialization
    output = []

    event_sum_curr = 0 # min: 0, max: 8191
    size_curr = size_max // 2
    for event_sum_next in array:
        size_next = size_curr + 1
        event_buf[event_idx % size_max] = event_sum_next
        esn = event_sum_next - event_sum_curr
        esp = event_sum_next + event_sum_curr
        for n in range(event_idx - 1, event_idx - size_curr, -1):
            event_sum_next = event_buf[n % size_max]
            esn += event_sum_next - event_sum_curr # min: -8191*64, max: 8191*64
            esp += event_sum_next + event_sum_curr # min: 0, max: (8191+8191)*64
            size_next -= esn**2 > ((t_a * esp) >> 8)
        output += [event_sum_curr + esn / size_curr]
        event_sum_curr += esn // size_curr
        size_curr = min(size_next, size_max)
        event_idx += 1

    return output

def cst_mcu_sc(array, t_a = 0x0100):
    # for n in $(seq 0 4095); do printf "0x%04X " $n; echo "sqrt($n/256)" | bc -l; done
    size_max = 64 # keep this value at 64 or lower

    event_buf = np.zeros(size_max, dtype=int)
    event_idx = 0 # starting value doesn't matter, safe to skip initialization
    output = [[], []]

    event_sum_curr = 0 # min: 0, max: 8191
    size_curr = size_max // 2
    for event_sum_next in array:
        size_next = size_curr + 1
        event_buf[event_idx % size_max] = event_sum_next
        esn = event_sum_next - event_sum_curr
        esp = event_sum_next + event_sum_curr
        for n in range(event_idx - 1, event_idx - size_curr, -1):
            event_sum_next = event_buf[n % size_max]
            esn += event_sum_next - event_sum_curr # min: -8191*64, max: 8191*64
            esp += event_sum_next + event_sum_curr # min: 0, max: (8191+8191)*64
            size_next -= esn**2 > ((t_a * esp) >> 8)
        output[0] += [event_sum_curr + esn / size_curr]
        output[1] += [size_curr]
        event_sum_curr += esn // size_curr
        size_curr = min(size_next, size_max)
        event_idx += 1

    return output

# Simple moving average
def sma(array, window_size = 64):
    input_size = len(array)
    output = []

    window = np.zeros(window_size)
    total = 0
    for i, e in enumerate(array):
        total += e - window[i % window_size]
        window[i % window_size] = e
        output += [total / window_size]

    return output

# Exponential moving average
def ema(array, window_size = 64, alpha = None):
    if alpha is None:
        alpha = 2 / (window_size + 1)
    alpha_array = []
    for i in range(window_size):
        alpha_array.append(np.power((1-alpha), i))

    alpha_sum = np.sum(alpha_array)

    input_size = len(array)
    output = []

    for i in range(input_size):
        if i < window_size:
            window = array[0:i]
        else:
            window = array[i - window_size + 1:i]

        exp_sum = 0

        for m, n in zip(reversed(window), alpha_array):
            exp_sum += m * n

        exp_avg = exp_sum / alpha_sum

        output.append(exp_avg)

    return np.array(output)

# RC filter with a given time constant
def rc_filter(array, tau = 8):
    alpha = 1 / (tau + 1)  # The actual formula is alpha = dt / (rc + dt) but the 1-second timestep simplifies things. Also tau = RC
    output = []
    last = 0
    for value in array:
        last = alpha * (value - last) + last
        output += [last]

    return output

def rc_filter_sc(array):
    global alphas
    output = []
    last = 0
    for value in zip(array[0], array[1]):
        last = alphas[value[1]] * (value[0] - last) + last
        output += [last]

    return output

# SMA with adaptive window size
# Source: https://habr.com/ru/articles/732456/
def sma_adaptive(array):
    max_windowsize=64
    target_counts = 500
    max_inter_rate = 500
    output = []

    for i in range(len(array)):
        window_sum = 0
        array_idx = i
        iterations = 0
        while (iterations < max_windowsize):
            iterations += 1
            window_sum += array[array_idx]
            array_idx -= 1
 
            if array_idx < 0: break   # reached end of the window
            if (window_sum * iterations >= max_inter_rate): break
            if (window_sum >= target_counts): break
        output.append(window_sum / iterations)

    return np.array(output)

# Adaptive tapped delay line FIR filter
# DOI: 10.1016/j.radmeas.2005.08.001
def fir_adaptive(array, method=1):
    assert (method == 1) or (method == 2), "fir_adaptive: method can only be 1 or 2"
    # The authors didn't specify FIR1 and FIR2 filter coefficients
    pass

def kalman(array):
    output = []
    Q = 0.04  # Process noise covariance, lower - smoother (def: 0.1)
    R = 5     # Measurement noise covariance, higher - smoother (def: 1.0)

    r_k = 0.5   # Initialize dose rate estimate
    P_k = 1.0 # Initialize error covariance

    for z_k in array:
        # Prediction step
        r_k_minus = r_k
        P_k_minus = P_k + Q

        # Update step
        K_k = P_k_minus / (P_k_minus + R)
        r_k = r_k_minus + K_k * (z_k - r_k_minus)
        P_k = (1 - K_k) * P_k_minus

        if (r_k < 0): r_k = 0
        output.append(r_k)

    return output

# Source: https://gist.github.com/balzer82/7f29431735306441b566
def alpha_beta(array):
    alpha = 0.25  # lower - smoother, def: 0.85
    beta = 0.001  # lower - more ringing suppression, def: 0.005
    dt = 1.0      # 1-second time step

    x_k = 0.0 # Initial position
    v_k = 0.0 # Initial velocity
    output = []

    for sample in array:
        x_k = x_k + v_k * dt
        r_k = sample - x_k
        x_k = x_k + alpha * r_k
        v_k = v_k + (beta * r_k) / dt
        if (x_k < 0): x_k = 0
        output.append(x_k)

    return output

# Generalized likelihood ratio
# DOI: 10.1016/j.nima.2008.06.050
def glr(array):
    # Based on SPRT but can actually smooth the data
    # Too complex for selected microcontroller
    pass

def cst_plus_func(array, func, min_alpha, max_alpha):
    peak_share = 0.25
    window_size = 64
    window = np.full(window_size, 1.0 / peak_share)

    c = cst_mcu(array)
    k = func(c)
    output = []

    total = window_size / peak_share
    for i, e in enumerate(array):
        total += e - window[i % window_size]
        window[i % window_size] = e
        alpha = 1 - min(peak_share * total / window_size, 1)
        alpha = min_alpha + alpha * (max_alpha - min_alpha)
        output += [k[i] * alpha + c[i] * (1 - alpha)]

    return output



def dump(array):
    for i, n in enumerate(array):
        print('%04X%c' % (n, ' ' if (i + 1) % 8 else '\n'), end = '')

def refresh(regen):
    global alphas
    global src_array
    if (regen):
        seed = int(np.random.rand() * (2**32 - 1))
        #seed = 1628747943
        np.random.seed(seed)
        print(seed)
        plt.title('Filter comparison (seed = %d)' % (seed))

        # Generate synthetic radiation pulse data
        # DOI: 10.1109/LASCAS.2016.7451002
        trials = 10000 # Bernoulli trials per element (1 second)
        src_array = np.zeros(len(ref_array), dtype=int)
        norm_array = ref_array / trials
        for j in range(trials):
            src_array += np.random.random(len(ref_array)) < norm_array

        #dump(src_array)
        #print('---')
        #dump(np.int32(cst_mcu(src_array)))

    cst_array_sc = cst_mcu_sc(src_array)
    cst_array = cst_array_sc[0]

    if 'a' in plots: plots['a'][0].set_ydata(src_array)
    if 'b' in plots: plots['b'][0].set_ydata(cst_array_sc[1])
    if 'c' in plots: plots['c'][0].set_ydata(cst_array)
    if 'd' in plots: plots['d'][0].set_ydata(rc_filter_sc(cst_array_sc))
    if 'e' in plots: plots['e'][0].set_ydata(rc_filter(cst_array, 3))
    if 'f' in plots: plots['f'][0].set_ydata(rc_filter(cst_array, 6))
    if 'g' in plots: plots['g'][0].set_ydata(rc_filter(cst_array, 9))
    if 'h' in plots: plots['h'][0].set_ydata(rc_filter(cst_array, 12))
    if 'i' in plots: plots['i'][0].set_ydata(rc_filter(cst_array, 15))

    fig.canvas.draw()
    fig.canvas.flush_events()

def on_press(event):
    if event.key == ' ':
        refresh(True)

def update_alphas(i, val):
    global alphas
    alphas[i] = 1 / val
    refresh(False)

color_idx = 0

def pick_color():
    colors = ('#6000FF', '#FF0080', '#0080FF', '#FF5000', '#00FFB0', '#FFA000', '#50D000', '#D0D000')
    global color_idx
    color_idx += 1
    return colors[(color_idx - 1) % len(colors)]

# Plot data
fig, ax = plt.subplots()
fig.canvas.mpl_connect('key_press_event', on_press)

plots = {
    'a': ax.plot(ref_array, linestyle='-', color='#C0C0C0', label = 'Raw data'),
    '.': ax.plot(ref_array, linestyle='-', color='#000000', label = 'Reference'),
    'b': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(1)'),
    'c': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(3)'),
    'd': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(5)'),
    #'e': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(7)'),
    #'f': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(9)'),
    #'g': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(11)'),
    #'h': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(13)'),
    #'i': ax.plot(ref_array, linestyle='-', color=pick_color(), label = 'RC(15)'),
}

mul = 2
xt = plt.gca().get_xticks()
xt = np.arange(0, len(ref_array), (xt[1] - xt[0] if len(xt) > 1 else 200) / mul)
plt.xticks(xt, xt * mul)

refresh(True)

plt.xlabel('Seconds')
plt.ylabel('CP2S')
plt.grid(True)
plt.legend()

axes = []
sliders = []
for y in range(8):
    for x in range(8):
        axes += [fig.add_axes(
                [1 - (7-x)/128, 1/64 + 0.125 * (7-y), 1/128, 0.125 - 1/64])]
        sliders += [Slider(ax = axes[8 * y + x], label = "",
                           valstep = 1, valmin = 1, valmax = 16,
                           valinit = 1 / alphas[8 * y + x],
                           orientation = "vertical")]
        sliders[8 * y + x].on_changed(lambda val, i = 8 * y + x: update_alphas(i, val))

plt.show()
